From 6a0713ce529cc2d188e6c12102109a6df507e7c9 Mon Sep 17 00:00:00 2001
From: Nathan Rossi <nathan@nathanrossi.com>
Date: Sun, 10 Apr 2022 16:28:23 +1000
Subject: [PATCH] WIP

---
 .../devicetree/bindings/net/dsa/marvell.txt    |  2 ++
 drivers/net/dsa/mv88e6xxx/port.c               | 18 ++++++++++++++++++
 drivers/net/dsa/mv88e6xxx/smi.c                | 13 +++++++++++++
 3 files changed, 33 insertions(+)

diff --git a/Documentation/devicetree/bindings/net/dsa/marvell.txt b/Documentation/devicetree/bindings/net/dsa/marvell.txt
index 2363b41241..ebf3e07ee1 100644
--- a/Documentation/devicetree/bindings/net/dsa/marvell.txt
+++ b/Documentation/devicetree/bindings/net/dsa/marvell.txt
@@ -41,6 +41,8 @@ Optional properties:
 			  switch. Must be set if the switch can not detect
 			  the presence and/or size of a connected EEPROM,
 			  otherwise optional.
+- single-chip-address	: Force use of single chip addressing, regardless of
+			  the MII address assigned for the node.
 - mdio			: Container of PHY and devices on the switches MDIO
 			  bus.
 - mdio?		: Container of PHYs and devices on the external MDIO
diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
index 795b312876..83142b8829 100644
--- a/drivers/net/dsa/mv88e6xxx/port.c
+++ b/drivers/net/dsa/mv88e6xxx/port.c
@@ -724,6 +724,24 @@ int mv88e6341_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
 	case PHY_INTERFACE_MODE_XAUI:
 	case PHY_INTERFACE_MODE_RXAUI:
 		return -EINVAL;
+	/*
+	 * Skip setting writable if the port is already configured correctly.
+	 * This check is done here before writable is set. Such that on devices
+	 * that are already correctly configured, no attempt is made to make
+	 * the cmode writable as it may fail.
+	 */
+	case PHY_INTERFACE_MODE_1000BASEX:
+		if (chip->ports[port].cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX)
+			return 0;
+		break;
+	case PHY_INTERFACE_MODE_SGMII:
+		if (chip->ports[port].cmode == MV88E6XXX_PORT_STS_CMODE_SGMII)
+			return 0;
+		break;
+	case PHY_INTERFACE_MODE_2500BASEX:
+		if (chip->ports[port].cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
+			return 0;
+		break;
 	default:
 		break;
 	}
diff --git a/drivers/net/dsa/mv88e6xxx/smi.c b/drivers/net/dsa/mv88e6xxx/smi.c
index a990271b74..e230bfe8ef 100644
--- a/drivers/net/dsa/mv88e6xxx/smi.c
+++ b/drivers/net/dsa/mv88e6xxx/smi.c
@@ -171,6 +171,19 @@ static const struct mv88e6xxx_bus_ops mv88e6xxx_smi_indirect_ops = {
 int mv88e6xxx_smi_init(struct mv88e6xxx_chip *chip,
 		       struct mii_bus *bus, int sw_addr)
 {
+	struct device_node *np = chip->dev->of_node;
+
+	if (np) {
+		/*
+		 * Determine if the switch should always be accessed in single
+		 * address mode regardless of mdio device address
+		 */
+		if (of_property_read_bool(np, "single-chip-address")) {
+			dev_info(chip->dev, "Using single chip addressing mode");
+			sw_addr = 0;
+		}
+	}
+
 	if (chip->info->dual_chip)
 		chip->smi_ops = &mv88e6xxx_smi_dual_direct_ops;
 	else if (sw_addr == 0)
