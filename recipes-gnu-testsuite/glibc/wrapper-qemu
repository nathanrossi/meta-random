#!/usr/bin/env python3

import sys
import os
import subprocess
import threading
import hashlib
import socket
import datetime
import random

# import common library packages
sys.path.append("/home/nathan/scripts/tools/lib")

import process

def format_bash(s):
	return " ".join(["'%s'" % i.replace("'", r"'\''") for i in s]) + "; "

qid = hashlib.md5((str(datetime.datetime.now()) + " ".join(sys.argv)).encode()).hexdigest()
qemulog_path = os.path.join(os.getcwd(), "qemu-%s.log" % qid)
qemulog = open(qemulog_path, "w")

def log(message, full = False):
	qemulog.write("%s\n" % message)
	qemulog.flush()
	if full:
		sys.stderr.write("%s\n" % message)
		sys.stderr.flush()

log("[qemu-auto] id = %s" % qid, full = True)

def monitor(data, error):
	line = data.decode(errors = "ignore").strip("\n")
	if error:
		log("[qemu-err] %s" % line, full = True)
	else:
		log("[qemu-out] %s" % line)
		if "openembedded nodistro" in data.decode().lower():
			log("[qemu-auto] -- hit ready --", full = True)
			systemready.set()

class Qemu:
	def __init__(self, args):
		self._args = args
		self._p = None
		self._port = None
		self._ready = False
		self._event = threading.Event()

	@staticmethod
	def _get_port():
		# try to find a port that is free
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		base = random.randrange(2222, 3222)
		while True:
			if s.connect_ex(("localhost", base)) != 0:
				s.close()
				return base
			base += 1
		s.close()
		return None

	def start(self, timeout = 120):
		if self._p is None:
			self._event.clear()

			nargs = list(self._args)
			self._port = Qemu._get_port()
			nargs += ["-netdev", "user,id=net0,hostfwd=tcp::%d-:22" % self._port]
			log("[qemu-args] '%s'" % repr(nargs), full = False)
			self._p = process.cmd(nargs, wait = False, write = True, capture = self._output)

			# wait for it to be ready
			timedout = self._event.wait(timeout) is False
			if timedout or not self._ready:
				self.kill()
				return False
			return True
		return True

	def _output(self, data, error):
		if data is None or len(data) == 0:
			self._event.set()
			return

		line = data.decode(errors = "ignore").strip("\n")
		if error:
			log("[qemu-err] %s" % line, full = True)
		else:
			log("[qemu-out] %s" % line)
			if "openembedded nodistro" in data.decode().lower():
				log("[qemu-auto] -- hit ready --", full = True)
				self._ready = True
				self._event.set()

	def kill(self):
		if self._p is not None:
			# os.kill(self._p.p.pid, signal.SIGKILL)
			self._p.kill()
			self._p.wait()
			self._p = None
			self._port = None

	def command(self, command):
		if self._port is None:
			return 0
		args = ["ssh", "-o", "UserKnownHostsFile=/dev/null", "-o", "StrictHostKeyChecking=no", "-p", "%d" % self._port, "root@localhost", "sh", "-c"]
		r = subprocess.run(args + [("\"%s\"" % command)])
		return r.returncode

	def __enter__(self):
		self.start()
		return self

	def __exit__(self, extype, exval, extb):
		self.kill()

# start up qemu user
systemready = threading.Event()
qemu_image_dir = "/mnt/storagedisk/nathan/build/mb-core/tmp-glibc/deploy/images/qemumicroblazeel"
qemu_args = [
		process.searchpath("qemu-system-microblazeel"),
		"-net", "nic,netdev=net0,macaddr=52:54:00:12:35:02",
		# "-netdev", "user,id=net0,hostfwd=tcp::2222-:22",
		"-initrd", os.path.join(qemu_image_dir, "core-image-minimal-qemumicroblazeel.cpio"),
		"-nographic",
		"-serial", "mon:stdio",
		"-machine", "petalogix-ml605",
		"-m", "512",
		"-kernel", os.path.join(qemu_image_dir, "uImage"),
		"-append", "'root=/dev/ram0 rw debugshell mem=512M ip=dhcp console=ttyS0,115200'"
	]

retry = 0
try:
	with Qemu(qemu_args) as qemu:
		while True:
			log("[qemu-auto] starting...", full = True)
			if not qemu.start():
				retry += 1
				log("[qemu-auto] failed to start, retry %d" % retry, full = True)
				continue

			log("[qemu-auto] started", full = True)

			# setup mount
			mntcmd = format_bash(["mkdir", "-p", "/mnt/storagedisk/nathan/build"]) + format_bash(["mount", "10.0.2.2:/mnt/storagedisk/nathan/build", "/mnt/storagedisk/nathan/build", "-o", "noac"])
			if qemu.command(mntcmd) != 0:
				log("[qemu-auto] mount failed", full = True)
				retry += 1
				log("[qemu-auto] failed to start, retry %d" % retry, full = True)
				qemu.kill()
				continue

			log("[qemu-auto] mount complete, starting command", full = True)

			command = ""
			# set timeout
			# command += format_bash(["export", "TIMEOUTFACTOR=100"])
			# change cwd
			command += format_bash(["cd", os.getcwd()])
			# run test
			command += format_bash(sys.argv[1:])
			r = qemu.command(command)

			log("[qemu-auto] result = %d" % r, full = True)
			sys.exit(r)
except KeyboardInterrupt:
	pass

